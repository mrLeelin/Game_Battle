# 3D JS Game Development Agent

è¿™æ˜¯ä¸€ä¸ªç”¨äº 3D JavaScript æ¸¸æˆå¼€å‘çš„ Claude Code Skillï¼Œæ”¯æŒ Three.jsã€Babylon.jsã€PlayCanvas ç­‰ä¸»æµå¼•æ“ã€‚

## è§¦å‘æ¡ä»¶

å½“ç”¨æˆ·è¯·æ±‚æ¶‰åŠä»¥ä¸‹å…³é”®è¯æ—¶è‡ªåŠ¨æ¿€æ´»ï¼š
- 3Dæ¸¸æˆã€ä¸‰ç»´æ¸¸æˆã€æ¸¸æˆå¼€å‘
- åœºæ™¯åˆ›å»ºã€åœ°å½¢ã€å¤©ç©ºç›’ã€å…‰ç…§
- æ¨¡å‹åŠ è½½ã€GLBã€FBXã€OBJ
- åŠ¨ç”»ã€éª¨éª¼åŠ¨ç”»ã€åŠ¨ç”»çŠ¶æ€æœº
- ç‰©ç†å¼•æ“ã€ç¢°æ’æ£€æµ‹ã€åˆšä½“
- å¤šäººæ¸¸æˆã€ç½‘ç»œåŒæ­¥ã€Socket
- æè´¨ã€PBRã€ç€è‰²å™¨ã€Shader
- æ€§èƒ½ä¼˜åŒ–ã€LODã€æ‰¹å¤„ç†
- Three.jsã€Babylon.jsã€PlayCanvas

## æ ¸å¿ƒèƒ½åŠ›

### ğŸ¬ åœºæ™¯æ­å»º
- åˆ›å»ºåŸºç¡€3Dåœºæ™¯ï¼ˆç›¸æœºã€æ¸²æŸ“å™¨ã€ç¯å…‰ï¼‰
- ç”Ÿæˆç¨‹åºåŒ–åœ°å½¢æˆ–åŠ è½½é«˜åº¦å›¾
- é…ç½®å¤©ç©ºç›’ï¼ˆCubeMapã€HDRã€ç¨‹åºåŒ–å¤©ç©ºï¼‰
- è®¾ç½®å¤šå…‰æºç³»ç»Ÿï¼ˆå¹³è¡Œå…‰ã€ç‚¹å…‰æºã€èšå…‰ç¯ã€ç¯å¢ƒå…‰ï¼‰

### ğŸ§± æ¨¡å‹ç®¡ç†
- åŠ è½½å¤šç§æ ¼å¼æ¨¡å‹ï¼ˆGLB/GLTFã€FBXã€OBJï¼‰
- æ¨¡å‹ä¼˜åŒ–ï¼ˆå‡é¢ã€åˆå¹¶ç½‘æ ¼ã€å®ä¾‹åŒ–ï¼‰
- LODï¼ˆLevel of Detailï¼‰å±‚çº§é…ç½®
- æ¨¡å‹åŠ¨æ€åŠ è½½ä¸å¸è½½

### ğŸ­ åŠ¨ç”»ç³»ç»Ÿ
- éª¨éª¼åŠ¨ç”»åŠ è½½ä¸æ’­æ”¾
- åŠ¨ç”»æ··åˆï¼ˆBlend Treeï¼‰
- åŠ¨ç”»çŠ¶æ€æœºé…ç½®
- ç¨‹åºåŒ–åŠ¨ç”»ï¼ˆIKã€ç‰©ç†åŠ¨ç”»ï¼‰

### ğŸ”« æ¸¸æˆé€»è¾‘
- ç©å®¶æ§åˆ¶å™¨ï¼ˆFPSã€TPSã€ä¿¯è§†è§’ï¼‰
- ç¢°æ’æ£€æµ‹ä¸å“åº”
- ç‰©ç†æ¨¡æ‹Ÿï¼ˆåˆšä½“ã€å…³èŠ‚ã€å¸ƒæ–™ï¼‰
- AI è¡Œä¸ºæ ‘ä¸çŠ¶æ€æœº

### ğŸŒ ç½‘ç»œåŒæ­¥
- å®ä½“çŠ¶æ€åŒæ­¥ï¼ˆä½ç½®ã€æ—‹è½¬ã€åŠ¨ç”»ï¼‰
- å®¢æˆ·ç«¯é¢„æµ‹ä¸æœåŠ¡å™¨æ ¡æ­£
- æ’å€¼ä¸å¤–æ¨å¹³æ»‘
- æˆ¿é—´ä¸åŒ¹é…ç³»ç»Ÿ

### ğŸ¨ æè´¨ä¸å…‰ç…§
- PBR æè´¨åˆ›å»ºä¸é…ç½®
- è‡ªå®šä¹‰ç€è‰²å™¨ç¼–å†™
- å®æ—¶é˜´å½±é…ç½®
- å…‰ç…§çƒ˜ç„™ä¸æ¢é’ˆ

### ğŸ“¦ æ€§èƒ½ä¼˜åŒ–
- Draw Call æ‰¹å¤„ç†
- çº¹ç†å‹ç¼©ä¸ Atlas
- å†…å­˜ç®¡ç†ä¸å¯¹è±¡æ± 
- å¼‚æ­¥åŠ è½½ä¸æµå¼åŠ è½½

### ğŸ› è°ƒè¯•å·¥å…·
- æ€§èƒ½ç»Ÿè®¡ï¼ˆFPSã€Draw Callã€ä¸‰è§’å½¢æ•°ï¼‰
- å†…å­˜åˆ†æ
- ç½‘ç»œå»¶è¿Ÿç›‘æ§
- å¯è§†åŒ–è°ƒè¯•ï¼ˆç¢°æ’ä½“ã€è·¯å¾„ã€å°„çº¿ï¼‰

## ä½¿ç”¨ç¤ºä¾‹

### åˆ›å»ºåŸºç¡€åœºæ™¯
```
ç”¨æˆ·: å¸®æˆ‘åˆ›å»ºä¸€ä¸ª Three.js åŸºç¡€åœºæ™¯
Agent: å°†ç”ŸæˆåŒ…å«ç›¸æœºã€æ¸²æŸ“å™¨ã€å…‰ç…§çš„å®Œæ•´åœºæ™¯ä»£ç 
```

### æ·»åŠ ç©å®¶æ§åˆ¶å™¨
```
ç”¨æˆ·: æ·»åŠ ä¸€ä¸ª FPS ç©å®¶æ§åˆ¶å™¨
Agent: ç”Ÿæˆç¬¬ä¸€äººç§°æ§åˆ¶å™¨ï¼ŒåŒ…å«ç§»åŠ¨ã€è·³è·ƒã€è§†è§’æ§åˆ¶
```

### ç½‘ç»œåŒæ­¥
```
ç”¨æˆ·: å¦‚ä½•åŒæ­¥å¤šä¸ªç©å®¶çš„ä½ç½®
Agent: æä¾›åŸºäº Socket.io çš„ä½ç½®åŒæ­¥æ–¹æ¡ˆå’Œä»£ç 
```

### æ€§èƒ½ä¼˜åŒ–
```
ç”¨æˆ·: åœºæ™¯å¤ªå¡äº†ï¼Œå¸®æˆ‘ä¼˜åŒ–
Agent: åˆ†ææ€§èƒ½ç“¶é¢ˆï¼Œæä¾›ä¼˜åŒ–å»ºè®®å’Œä»£ç ä¿®æ”¹
```

## ä»£ç æ¨¡æ¿

### Three.js åŸºç¡€åœºæ™¯æ¨¡æ¿
```javascript
// åœºæ™¯åˆå§‹åŒ–
import * as THREE from 'three';

export class GameScene {
  constructor(container) {
    this.container = container;
    this.scene = new THREE.Scene();
    this.camera = null;
    this.renderer = null;
    this.clock = new THREE.Clock();

    this.init();
  }

  init() {
    // ç›¸æœº
    this.camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    this.camera.position.set(0, 5, 10);

    // æ¸²æŸ“å™¨
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.container.appendChild(this.renderer.domElement);

    // å…‰ç…§
    this.setupLights();

    // å“åº”å¼
    window.addEventListener('resize', () => this.onResize());
  }

  setupLights() {
    // ç¯å¢ƒå…‰
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
    this.scene.add(ambientLight);

    // å¹³è¡Œå…‰ï¼ˆæ¨¡æ‹Ÿå¤ªé˜³ï¼‰
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(50, 50, 50);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    this.scene.add(directionalLight);
  }

  onResize() {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }

  update() {
    const delta = this.clock.getDelta();
    // æ›´æ–°æ¸¸æˆé€»è¾‘
  }

  render() {
    this.renderer.render(this.scene, this.camera);
  }

  animate() {
    requestAnimationFrame(() => this.animate());
    this.update();
    this.render();
  }

  start() {
    this.animate();
  }
}
```

### FPS æ§åˆ¶å™¨æ¨¡æ¿
```javascript
import * as THREE from 'three';
import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls';

export class FPSController {
  constructor(camera, domElement) {
    this.camera = camera;
    this.controls = new PointerLockControls(camera, domElement);

    this.velocity = new THREE.Vector3();
    this.direction = new THREE.Vector3();

    this.moveForward = false;
    this.moveBackward = false;
    this.moveLeft = false;
    this.moveRight = false;
    this.canJump = true;

    this.speed = 10;
    this.jumpForce = 10;

    this.init();
  }

  init() {
    document.addEventListener('keydown', (e) => this.onKeyDown(e));
    document.addEventListener('keyup', (e) => this.onKeyUp(e));

    this.controls.addEventListener('lock', () => {
      console.log('Pointer locked');
    });

    this.controls.addEventListener('unlock', () => {
      console.log('Pointer unlocked');
    });
  }

  onKeyDown(event) {
    switch (event.code) {
      case 'KeyW': this.moveForward = true; break;
      case 'KeyS': this.moveBackward = true; break;
      case 'KeyA': this.moveLeft = true; break;
      case 'KeyD': this.moveRight = true; break;
      case 'Space':
        if (this.canJump) {
          this.velocity.y = this.jumpForce;
          this.canJump = false;
        }
        break;
    }
  }

  onKeyUp(event) {
    switch (event.code) {
      case 'KeyW': this.moveForward = false; break;
      case 'KeyS': this.moveBackward = false; break;
      case 'KeyA': this.moveLeft = false; break;
      case 'KeyD': this.moveRight = false; break;
    }
  }

  update(delta) {
    if (!this.controls.isLocked) return;

    // å‡é€Ÿ
    this.velocity.x -= this.velocity.x * 10.0 * delta;
    this.velocity.z -= this.velocity.z * 10.0 * delta;
    this.velocity.y -= 9.8 * delta; // é‡åŠ›

    // æ–¹å‘
    this.direction.z = Number(this.moveForward) - Number(this.moveBackward);
    this.direction.x = Number(this.moveRight) - Number(this.moveLeft);
    this.direction.normalize();

    // ç§»åŠ¨
    if (this.moveForward || this.moveBackward) {
      this.velocity.z -= this.direction.z * this.speed * delta;
    }
    if (this.moveLeft || this.moveRight) {
      this.velocity.x -= this.direction.x * this.speed * delta;
    }

    this.controls.moveRight(-this.velocity.x * delta);
    this.controls.moveForward(-this.velocity.z * delta);

    // åœ°é¢æ£€æµ‹
    if (this.camera.position.y < 1.6) {
      this.velocity.y = 0;
      this.camera.position.y = 1.6;
      this.canJump = true;
    }
  }

  lock() {
    this.controls.lock();
  }

  unlock() {
    this.controls.unlock();
  }
}
```

### ç½‘ç»œåŒæ­¥æ¨¡æ¿
```javascript
import { io } from 'socket.io-client';

export class NetworkManager {
  constructor() {
    this.socket = null;
    this.players = new Map();
    this.localPlayer = null;
    this.interpolationDelay = 100; // ms
  }

  connect(serverUrl) {
    this.socket = io(serverUrl);

    this.socket.on('connect', () => {
      console.log('Connected to server');
    });

    this.socket.on('playerJoined', (data) => {
      this.addPlayer(data.id, data.position);
    });

    this.socket.on('playerLeft', (data) => {
      this.removePlayer(data.id);
    });

    this.socket.on('gameState', (state) => {
      this.updateGameState(state);
    });
  }

  addPlayer(id, position) {
    // åˆ›å»ºè¿œç¨‹ç©å®¶å¯¹è±¡
    const player = {
      id,
      position: { ...position },
      targetPosition: { ...position },
      lastUpdate: Date.now()
    };
    this.players.set(id, player);
  }

  removePlayer(id) {
    this.players.delete(id);
  }

  updateGameState(state) {
    for (const playerData of state.players) {
      const player = this.players.get(playerData.id);
      if (player) {
        player.targetPosition = playerData.position;
        player.lastUpdate = Date.now();
      }
    }
  }

  sendPosition(position) {
    if (this.socket && this.socket.connected) {
      this.socket.emit('updatePosition', {
        position,
        timestamp: Date.now()
      });
    }
  }

  // æ’å€¼æ›´æ–°è¿œç¨‹ç©å®¶ä½ç½®
  interpolatePlayers(delta) {
    const now = Date.now();

    for (const player of this.players.values()) {
      const t = Math.min(1, (now - player.lastUpdate) / this.interpolationDelay);

      player.position.x += (player.targetPosition.x - player.position.x) * t;
      player.position.y += (player.targetPosition.y - player.position.y) * t;
      player.position.z += (player.targetPosition.z - player.position.z) * t;
    }
  }

  disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
  }
}
```

## å¼•æ“åˆ‡æ¢

Agent é»˜è®¤ä½¿ç”¨ Three.jsï¼Œä½†å¯ä»¥æ ¹æ®éœ€æ±‚åˆ‡æ¢åˆ°å…¶ä»–å¼•æ“ï¼š

### Babylon.js
```
ç”¨æˆ·: ä½¿ç”¨ Babylon.js åˆ›å»ºåœºæ™¯
Agent: åˆ‡æ¢åˆ° Babylon.js æ¨¡æ¿
```

### PlayCanvas
```
ç”¨æˆ·: ç”¨ PlayCanvas å¼€å‘
Agent: åˆ‡æ¢åˆ° PlayCanvas æ¨¡æ¿
```

## ä¸é¡¹ç›®é›†æˆ

æœ¬ Agent ä¸ Battle é¡¹ç›®æ·±åº¦é›†æˆï¼š
- å¤ç”¨ `shared/` ç›®å½•çš„å¸¸é‡å’Œäº‹ä»¶å®šä¹‰
- å…¼å®¹ç°æœ‰çš„ Socket.io ç½‘ç»œæ¶æ„
- éµå¾ªé¡¹ç›®çš„æ¨¡å—åŒ–è®¾è®¡åŸåˆ™
- æ¸¸æˆé€»è¾‘æ”¾åœ¨ `client/games/` å’Œ `server/games/`

## è°ƒè¯•æ¨¡å¼

å¯ç”¨è°ƒè¯•æ¨¡å¼è·å–æ›´å¤šä¿¡æ¯ï¼š
```
ç”¨æˆ·: å¼€å¯è°ƒè¯•æ¨¡å¼
Agent: å¯ç”¨è¯¦ç»†æ—¥å¿—ã€æ€§èƒ½ç»Ÿè®¡ã€å¯è§†åŒ–è°ƒè¯•
```

## æ³¨æ„äº‹é¡¹

1. **æ€§èƒ½ä¼˜å…ˆ**ï¼šç”Ÿæˆçš„ä»£ç é»˜è®¤è€ƒè™‘æ€§èƒ½ä¼˜åŒ–
2. **æ¨¡å—åŒ–è®¾è®¡**ï¼šä»£ç æŒ‰åŠŸèƒ½æ¨¡å—æ‹†åˆ†ï¼Œä¾¿äºç»´æŠ¤
3. **ç±»å‹å®‰å…¨**ï¼šæ¨èä½¿ç”¨ TypeScriptï¼ˆå¯é€‰ï¼‰
4. **è·¨å¹³å°**ï¼šè€ƒè™‘æ¡Œé¢å’Œç§»åŠ¨ç«¯å…¼å®¹æ€§
5. **ç½‘ç»œä¼˜åŒ–**ï¼šå¤šäººæ¸¸æˆä»£ç åŒ…å«å»¶è¿Ÿè¡¥å¿
